---
page_title: module block reference
description: Learn how to configure a `module` block, which instructs Terraform to create resources defined in a local or remote module.
---

# `module` block reference

The `module` block instructs Terraform to create resources defined in a local or remote module. A module is a container for multiple resources that are used together. Refer to the following topics for more information:

- [Modules](#): 
- [Configure modules](#)
- [Write modules](#)
- [Publish modules](#)
- [Use and develop modules](#)

## Configuration model

A `module` block supports the following configuration:

- [`module "<LABEL>"`]() &nbsp block
  - [<module-specific-inputs>](#module-specific-inputs)
  - [`source`](#source) &nbsp string | required
  - [`version`](#version) &nbsp string 
  - [`count`](#count) &nbsp number | mutually exclusive with `for_each`
  - [`depends_on`](#depends_on) &nbsp list of references 
  - [`for_each`](#for_each): nbsp map or set of strings | mutually exclusive with `count`
  - [`provider`](#provider) &nbsp reference


  
## Complete configuration

The following `module` block includes all built-in arguments:

```hcl
module "<LABEL>" {
  <module-specific-inputs>
  source = "<location-of-module-sources>"
  version = "<constraint>" # only available for modules listed in a registry
  count = <number> # mutually exclusive with `for_each`
  for_each = {          # `for_each` and `count` are mutually exclusive 
      <KEY> = <VALUE>
   }
   for_each = [       # `for_each` accepts a map or a set of strings 
    "<VALUE>", 
    "<VALUE>"
   ]
  provider`](#provider) &nbsp reference
  depends_on = [ <resource.address.reference> ] 
``` 

## Specification

A `module` block supports the following configuration.

### `module "<LABEL>"`

The `LABEL` is a local name for the module. Use the `module.<label>.<attribute`> syntax to reference data in the module. Refer to [References to Named Values](/terraform/language/expressions/references) and [Resource naming](/terraform/language/style#resource-naming) for expression syntax and label recommendations.

### Module-specific inputs

The module developer determines which inputs you can specify for the module. Refer to the module documentation for details.

### `source`

The `source` specifies the location of a module's configuration files. 

```hcl
module "<LABEL>" {
  source = "<location-of-module-files>"
  #...
}
```


The location is a local file or directory or a remote module source. You must specify a literal string. Template sequences and arbitrary expressions are not supported. Refer to [Module Sources](/terraform/language/modules/sources) for more information.

You can specify the same source address in two or more separate `module` blocks, but you must use unique labels for each block. This creates multiples of the resources defined in the child module. You can use different variable input values for each module to create variations of the same kind of resources. 

You must run [`terraform init`](/terraform/cli/commands/init) after adding, removing, or modifying a `module` block. Note that the command does not upgrade an already-installed module. You must also include the `-upgrade` option to upgrade to the newest available version.

Module source code stored in a version control repository or archive file, referred to as a **package**, may be in a sub-directory relative to the root of the package. Add `//` to the source path to indicate that the rest of the path after that point is a sub-directory within the package. For example:

- `hashicorp/consul/aws//modules/consul-cluster`
- `git::https://example.com/network.git//modules/vpc`
- `https://example.com/network-module.zip//modules/vpc`
- `s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/network.zip//modules/vpc`

Place any query parameters, such as the `ref` argument supported for the version control sources, after the the sub-directory segment, for example:

- `git::https://example.com/network.git//modules/vpc?ref=v1.2.0`
- `github.com/hashicorp/example//modules/vpc?ref=v1.2.0`

Terraform extracts the entire package to local disk, but reads the module from the subdirectory. As a result, modules in a sub-directory of a package can use a [local path](#local-paths) to reference another module in the same package.

You can configure Terraform to install modules from the following types of sources.

#### Local paths

Use the `./` or `../` prefix followed by the path to local module source code to install a module from files already on disk:

`source = "./<PATH-TO-MODULE>"` 

Terraform recognizes paths that begin with a `/` or drive letter as absolute paths. Terraform copies modules specified with an absolute path to the local module cache as a package. We don't recommend using absolute filesystem paths to refer to Terraform modules because doing so can couple your configuration to the filesystem layout of a particular computer.

Refer to [Install modules on the local disk](#install-modules-on-the-local-disk) for an example.
  
#### Terraform registry

The primary workflow for sharing modules across multiple configurations is to distribute them through either the [public Terraform registry](https://registry.terraform.io/browse/modules) or through a private registry in [HCP Terraform](/terraform/cloud-docs/registry) or [Terraform Enterprise](/terraform/enterprise/registry). You can also create a private registry by operating a custom service that implements the [module registry protocol]/terraform/registry/api-docs).

The Terraform-specific protocol for retrieving modules from a registry has full support for module versioning. Refer to the documentation where your module is listed for more information.

Use the following syntax to install modules listed in the public Terraform registry:

`<NAMESPACE>/<NAME>/<PROVIDER>` 

For modules listed in an HCP Terraform private registry, prepend the path with `app.terraform.io`:

`app.terraform.io/<NAMESPACE>/<NAME>/<PROVIDER>` 

For modules listed in your Terraform Enterprise private registry, prepend the path with the hostname of your deployment:

`<HOSTNAME>/<NAMESPACE>/<NAME>/<PROVIDER>`

When operating Terraform in HCP Terraform and Terraform Enterprise, you can also specify the `localterraform.com` hostname. The `localterraform.com` hostname requests modules from the instance that the platform is running on. Refer to is a [Generic hostname](/terraform/cloud-docs/registry/using#generic-hostname-hcp-terraform-and-terraform-enterprise) for more information:

`localterraform.com/<NAMESPACE>/<NAME>/<PROVIDER>` 

Refer to [Install modules from a registry](#install-modules-from-a-registry) for examples.

#### GitHub repository

Use the following syntax to clone module sources from GitHub over HTTPS:

`github.com/<ORGANIZATION>/<MODULE-FOLDER>`
 
Use the following syntax to clone module sources from GitHub over SSH:

`git:github.com/<ORGANIZATION>/<MODULE-FOLDER>`

Terraform runs `git clone` to install modules. Terraform uses the Git configurations set on your local system, including credentials, when running the command. To access a non-public repository, configure Git with suitable credentials.

For SSH connections, Terraform automatically uses your SSH keys. This is the most common way to access non-public Git repositories from automated systems because it allows access to non-pubic repositories without interactive prompts.

For HTTP, HTTPS, and any other protocol that requires a username and password to authenticate, refer to [Git documentation](https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage) for guidance on providing credentials.

If your Terraform configuration runs in [HCP Terraform](/terraform/cloud-docs), you can only authenticate using SSH keys. Refer to [Use SSH keys to clone modules](/terraform/cloud-docs/workspaces/settings/ssh-keys) for instructions.

You can also specify the following query parameters:
 
`ref`: Specifies a branch name, full or short SHA-1 hash, or tag name to clone. Refer to the [Git tools documentation](https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection#_single_revisions)
for more information. Terraform defaults to the default branch referenced by `HEAD` in the repository.

`depth`: Instructs Terraform to perform a shallow clone and specifies the depth of the commit history to include. The default is `1`. 

The `depth` parameter implements the [Git `--depth` option](https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---depthltdepthgt). When the `source` argument includes the `depth` parameter, Terraform passes the `ref` argument to the `--branch` option when running the `git clone` command. As a result, you must specify a named branch or tag known to the remote repository. Raw commit IDs are not acceptable. Refer to [the Git `--branch` documentation](https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---branchltnamegt) for more information. 

Refer to [Install modules from GitHub](#install-modules-from-a-github) for examples.

#### General Git repository

Use the `git::` prefix followed by any valid
[Git URL](https://git-scm.com/docs/git-clone#_git_urls), including the protocol, to install a module from a general Git repository:

- `source = "ssh://[<user>@]<host>[:<port>]/<path-to-git-repo>"`
- `source = "git://<host>[:<port>]/<path-to-git-repo>"`
- `source = "http://<host>[:<port>]/<path-to-git-repo>"`
- `source = "https://<host>[:<port>]/<path-to-git-repo>"`
- `source = "ftp://<host>[:<port>]/<path-to-git-repo>"`
- `source = "ftps://<host>[:<port>]/<path-to-git-repo>"`

As an alternate format for SSH connections, you can use an scp-like URL by omitting `ssh://`:

`git::[<USER>@]<HOST>/<PATH-TO-GIT-REPO>`

Refer to the [Git URL documentation](https://git-scm.com/docs/git-clone#_git_urls) for details. We recommend using the `ssh://`-prefixed URL for consistency.

Terraform runs `git clone` to install modules. Terraform uses the Git configurations set on your local system, including credentials, when running the command. To access a non-public repository, configure Git with suitable credentials.

For SSH connections, Terraform automatically uses your SSH keys. This is the most common way to access non-public Git repositories from automated systems because it allows access to private repositories without interactive prompts.

For HTTP, HTTPS, and any other protocol that requires a username and password to authenticate, refer to [Git documentation](https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage) for guidance on providing credentials.

If your Terraform configuration runs in [HCP Terraform](/terraform/cloud-docs), you can only authenticate using SSH keys. Refer to [Use SSH keys to clone modules](/terraform/cloud-docs/workspaces/settings/ssh-keys) for instructions.

You can also add the following query parameters to general Git repository URLs:
 
`ref`: Specifies a branch name, full or short SHA-1 hash, or tag name to clone. Refer to the [Git tools documentation](https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection#_single_revisions)
for more information. Terraform defaults to the default branch referenced by `HEAD` in the repository.

`depth`: Instructs Terraform to perform a shallow clone and specifies the depth of the commit history to include. The default is `1`. 

This argument implements the Git `--depth` option. Refer to the [Git documentation](https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---depthltdepthgt) for more information. Including the `depth` argument instructs Terraform to pass your`ref` argument to the `--branch` argument during the `git clone` operation. Refer to [the Git `--branch` documentation](https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---branchltnamegt) for more information. As a result, you must specify a named branch or tag known to the remote repository. Raw commit IDs are not acceptable. 

Refer to [Install modules from a Git repository](#install-modules-from-a-git-repository) for examples.

#### Bitbucket

Use the with `bitbucket.org` prefix to reference to modules hosted in BitBucket:

`bitbucket.org/<PATH-TO-MODULE-SOURCES>`

BitBucket is a service that hosts Git repositories. Refer to [General Git repository](#generic-git-repository) for information about supported parameters and configuring credentials for private repositories.

Refer to [Install modules from a repository listed hosted on BitBucket ](#install-modules-from-a-repository-listed-hosted-on-bitbucket) for example configurations.
#### Mercurial repository

Use the `hg::` prefix followed by a valid
[Mercurial URL](https://www.mercurial-scm.org/repo/hg/help/urls) to install modules stored in a Mercurial repository:

- `hg::file://local/filesystem/path[#revision]`
- `hg::http://[user[:pass]@]host[:port]/[path][#revision]`
- `hg::https://[user[:pass]@]host[:port]/[path][#revision]`
- `hg::ssh://[user@]host[:port]/[path][#revision]`
- `hg::path://pathname`

Terraform runs `hg clone` to install modules. Terraform uses the Mercurial configurations set on your local system, including credentials, when running the command. To access a private repository, configure Mercurial with suitable credentials.

For SSH connections, Terraform automatically uses your SSH keys. This is the most common way to access non-public Mercurial repositories from automated systems because it allows access to private repositories without interactive prompts.

If your Terraform configuration runs in [HCP Terraform](/terraform/cloud-docs), you can only authenticate using SSH keys. Refer to [Use SSH keys to clone modules](/terraform/cloud-docs/workspaces/settings/ssh-keys) for instructions.

Refer to [Install modules from a Mercurial repository](#install-modules-from-a-mercurial-repository) for an example configuration.

#### HTTL URLs

You can specify an HTTP or HTTPS URL in the `source` argument to use vanity URLs instead of hard-coding complex module source paths in the Terraform configuration. Specifying a URL instructs Terraform to send a `GET` request to the URL. The service listening for requests can construct and respond with a module source address. 

Terraform appends a `terraform-get=1` query string parameter to the URL before sending the `GET` request so that the server can optionally return a different result when Terraform is requesting it.

When Terraform receives a response with a successful `200` code, it checks the following locations for the module source address:

- The value of a response header field named `X-Terraform-Get`.
- If the response is an HTML page, a `meta` element with the name `terraform-get`:

  ```html
  <meta name="terraform-get" content="<module-source>" />
  ```

Terraform interprets the result as the source address so that it can install the module.

By default, Terraform searches your `HOME` directory for a `.netrc` file when the listening service requests credentials for authentication. You can set the `NETRC` environment variable to override the default filesystem location. For information on the `.netrc` format,
refer to [the documentation for using it in `curl`](https://everything.curl.dev/usingcurl/netrc).

If an HTTPS URL has a common file extension associated with an archive file format, Terraform bypasses the `terraform-get=1` redirection and uses the contents of the referenced archive as the module source code. 

Terraform recognizes the following archive extensions:

- `zip`
- `bz2`, `tar.bz2`, `tar.tbz2`, and `tbz2`
- `gz`, `tar.gz`, and `tgz`
- `xz`, `tar.xz`, and `txz`

For URLs that have any other archive extension format, you can add the `archive` query parameter.

When the content of the archive file is a directory, you must include the directory in the module source. Refer to [Modules in Package Sub-directories](#modules-in-package-sub-directories) for more information.

Refer to [Query an HTTPS URL for the module source](#query-an-https-url-for-the-module-source) for an example.
#### S3 bucket

Use the ``s3::` prefix followed by an [S3 bucket object URL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingBucket.html) to install modules from sources stored as an archive in S3. 

The object stored in the S3 bucket must be an archive with one of the following extensions:

- `zip`
- `bz2`, `tar.bz2`, `tar.tbz2`, and `tbz2`
- `gz`, `tar.gz`, and `tgz`
- `xz`, `tar.xz`, and `txz`

Terraform extracts the archive to obtain the module source tree.

Buckets in AWS's us-east-1 region must use the hostname `s3.amazonaws.com`, instead of `s3-us-east-1.amazonaws.com`.

The module installer checks for AWS credentials in the following locations in order of precedence:

1. The `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` environment variables.
1. The default profile in the `.aws/credentials` file in your home directory.
1. If running on an EC2 instance, temporary credentials associated with the instance's IAM instance profile.

Other AWS services may handle authentication in a manner similar to the S3 API. As a result, you may be able to use the `s3::` format for other services.

Refer to [Install a module from an S3 bucket object](#install-a-module-from-an-s3-bucket-object) for an example.

#### GCS bucket

Use the `gcs::` prefix followed by a [GCS bucket object URL](https://cloud.google.com/storage/docs/request-endpoints#typical) to install modules stored as archive files in Google Cloud Storage:

- `gcs::https://www.googleapis.com/storage/v1/BUCKET_NAME/PATH_TO_MODULE`
- `gcs::https://www.googleapis.com/storage/v1/BUCKET_NAME/PATH/TO/module.zip`


The module installer uses Google Cloud SDK to authenticate with GCS. You can use any of the following methods to set Google Cloud Platform credentials:

- Set the `GOOGLE_OAUTH_ACCESS_TOKEN` environment variable to a raw Google Cloud Platform OAuth access token.
- Enter the path of your service account key file in the `GOOGLE_APPLICATION_CREDENTIALS` environment variable.
- If Terraform is running on a GCE instance, default credentials are automatically available. Refer to the [GCE documentation for](https://cloud.google.com/compute/docs/access/create-enable-service-accounts-for-instances) for details.
- On your computer, you can make your Google identity available by running [`gcloud auth application-default login`command](https://cloud.google.com/sdk/gcloud/reference/auth/application-default/login).


Refer to [Install a module from a GCS bucket](#install-a-module-from-a-gcs-bucket) for an example.

#### Summary

- Data type: String.
- Default: None.
- Examples: [Specify the location of module source files](#specify-the-location-of-module-source-files)

### `version`

The `version` argument specifies which version of the module to use. This argument is only applicable when installing modules from a registry:

```hcl
module "LABEL" {
  version = "<constraint>"
}
```

We recommend explicitly constraining the acceptable version numbers to avoid unexpected or unwanted changes.

The `version` argument accepts a [version constraint string](/terraform/language/expressions/version-constraints). Terraform uses the newest installed version of the module that meets the constraint. When an acceptable version isn't installed, Terraform downloads the newest version that meets the constraint.

You can only use the `version` argument when the [`source` argument](#source) points to a module listed in a registry, such as the public [Terraform Registry](https://registry.terraform.io/)
or [HCP Terraform's private module registry](/terraform/cloud-docs/registry).

Refer to the documentation for the module for versioning mechanisms specific to the module. Modules sourced from local file paths do not support `version` because they're loaded from the same source repository and always share the same version as their caller.

#### Summary

- Data type: String
- Default: Defaults to latest version available from the source
- Example: [Specify a module version from a registry](#specify-a-module-version-from-a-registryl)

### `count`

The `count` meta-argument instructs Terraform to provision multiple instances of the same module with identical or similar configuration.   

```hcl
module "<LABEL>" {
  count = <number>
}
```

You can reference variables or local values and use expressions to compute the value, but the value must resolve to a whole number.

In blocks where `count` is set, Terraform exposes an additional `count` object. You can reference the object to modify the configuration of each instance. The `count` object has an `index` attribute starting from `0`.

To refer to an individual instance of a module resource created using the `count` meta-argument, use the `module.<NAME>[INDEX]` syntax. For example, `module.server[0]` refers to the first instance of the module named `server`.

<Tip>

You can use the `count` argument as a conditional for creating modules. For example, setting a `count = var.creator ? 3 : 0` instructs Terraform to create three instances of the module resources when a variable named `creator` is set to `true`. Refer to [​​Conditional Expressions]/terraform/language/expressions/conditionals) for more information.

</Tip>

The `count` argument is a meta-argument, which is built into Terraform and controls the way that Terraform creates resources. Refer to [Meta-arguments](/terraform/language/meta-arguments) for more information.

#### Summary

- Data type: Number
- Default: None
- Example: [Create multiple version of module resources](#create-multiple-versions-of-module-resources)

### `for_each`

The `for_each` meta-argument instructs Terraform to provision similar modules without requiring separate configuration blocks for each resource.


<Tabs>

<Tab heading="List of values">

```hcl
module "<LABEL>" {
  for_each = [ "<VALUE>" ] 
  # . . .
}
```

</Tab>

<Tab heading="Map of key-value pairs">

```hcl
module "<LABEL>" {
  for_each = {
    "<KEY>" = "<VALUE>"
  }
}
```

</Tab>

</Tabs>


The `for_each` meta-argument accepts a map or a set of strings and creates an instance for each item in that map or set. Each instance is associated with a distinct infrastructure object. Terraform creates, updates, or destroys each instance when applying changes to the configuration.

You can use pure functions, such as `toset()` and `tomap()`, to create a map or set for use in the `for_each` argument. Whether iterating over the keys of a map or set of strings, all must be known values. Otherwise, Terraform prints an error message that `for_each` has dependencies that it cannot determine before applying the configuration.

Keys in the `for_each` argument cannot be the result of or rely on the result of impure functions, including `uuid`, `bcrypt`, or `timestamp`, because Terraform defers evaluating impure functions during the main evaluation step.

The `for_each` argument does not implicitly convert lists or tuples to sets. To declare modules based on a nested data structure or combinations of elements from multiple data structures, you can use Terraform expressions and functions to derive a suitable value. Refer to the following examples for more information:

- [Transform a multi-level nested structure into a flat list](/terraform/language/functions/flatten#flattening-nested-structures-for-for_each).
- [Combine collections to produce a list of element combinations](/terraform/language/functions/setproduct#finding-combinations-for-for_each).

You cannot use sensitive values, such as [sensitive input variables](/terraform/language/values/variables#suppressing-values-in-cli-output), [sensitive outputs](/terraform/language/values/outputs#sensitive-suppressing-values-in-cli-output), or [sensitive resource attributes](/terraform/language/expressions/references#sensitive-resource-attributes), as arguments in `for_each`. Terraform uses the value in `for_each` to identify the module instance and always discloses it in UI output, so sensitive values are not allowed. Terraform returns an error if you attempt to use sensitive values as `for_each` arguments.

If you transform a value containing sensitive data into an argument for use in `for_each`, most functions in Terraform return a sensitive result when given an argument with any sensitive content. In many cases, you can achieve similar results with a `for` expression. For example, to call `keys(local.map)` where `local.map` is an object with sensitive values, but non-sensitive keys, you can create a value to pass to `for_each` using `toset([for k,v in local.map : k])`.

Refer to [Sensitive Data in State](/terraform/language/state/sensitive-data) for more information. 

The `for_each` argument exposes an `each` object that you can reference within the same block to modify specific instances of the module. The object has the following attributes:

- `each.key`: Map key or list member that corresponds to an instance.
- `each.value`: Map value that corresponds to an instance. 

Use the `module.<NAME>[<KEY>]` syntax to access an instance of a module created using `for_each`. For example, `module.rg["a_group"]` refers to a module resource named `rg` created off of the `a_group` key.

The `for_each` argument is a meta-argument, which is built into Terraform and controls the way that Terraform creates resources. Refer to [Meta-arguments](/terraform/language/meta-arguments) for more information.

#### Summary

- Data type: Map or set of strings.
- Default: None. 
- Example: [Create multiple version of module resources](#create-multiple-versions-of-module-resources) 

### `provider`

The `provider` argument instructs Terraform to use an alternate provider configuration. 

```hcl
module "<LABEL>" {
  provider = <provider>.<alias>
}
```


By default, Terraform automatically selects a provider based on the data source type, but you can create multiple provider configurations and use a non-default configuration for specific modules. 

Use the `<PROVIDER>.<ALIAS>` syntax to reference a provider configuration in the `provider` argument. Refer to [Multiple Provider Configurations](/terraform/language/providers/configuration#alias-multiple-provider-configurations) for instructions on how to reference a specific provider configuration.     

The `provider` argument is a meta-argument, which is built into Terraform and controls the way that Terraform creates resources. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for more information.

#### Summary

- Data type: Reference.
- Default: None. 
- Example: [Select an alternate provider configuration](#select-an-alternate-provider-configuration)


### `depends_on`

The `depends_on` meta-argument specifies an upstream resource that the module depends on. Terraform must complete all operations on the upstream resource before performing operations on the module containing the `depends_on` argument.

```hcl
module "<LABEL>" {
  depends_on = [ <resource reference> ]
}
```

When a module configuration refers to another resource, Terraform identifies the dependency and creates the upstream resource first. In some cases, you may need Terraform to create one resource before creating a module, even though the resource and the module are configured independently.

Use the `depends_on` argument when the resource and module do not reference each other. We recommend always including a comment to explain dependencies when using a `depends_on` argument.

When using the `depends_on` meta-argument, you can only reference other resources or child modules in the same root module. The list cannot include arbitrary expressions. Any values referenced in the `depends_on` list must be known before Terraform begins the operation so that it can evaluate dependencies.

Specifying an entire module in the `depends_on` argument affects the order in which Terraform provisions all of the resources and data modules associated with that module. Refer to [Resource dependencies](/terraform/language/manage-resources#resource-dependencies)<!--PAGE TBD → and [Data resource dependencies](/terraform/language/configure-data-sources#data-resource-dependencies) for more information.

The depends_on argument is a meta-argument, which is built into Terraform and controls the way that Terraform creates resources. Refer to [Meta-arguments](/terraform/language/concepts/meta-arguments) for more information.

#### Summary

- Data type: List.
- Default: None.
- Example: [Specify a dependency](#specify-a-dependency)

## Examples

The following examples show how to write configuration for common use cases.

### Specify the location of module source files

You can source modules for use in your configuration from several types of locations. 

#### Install modules on the local disk

The following example clones a module stored in the `/consul` directory within the current working directory:

```hcl
module "consul" {
  source = "./consul"
}
``` 

#### Install modules from a registry

The following example clones a module listed in the public Terraform registry:

```hcl
module "consul" {
  source = "hashicorp/consul/aws"
  version = "0.1.0"
}
``` 

The following example clones a module listed in a private registry on HCP Terraform:

```hcl
module "consul" {
  source = "app.terraform.io/example-corp/k8s-cluster/azurerm"
  version = "1.1.0"
}

```

#### Install modules from GitHub

The following example clones the `example` module from GitHub over HTTPS:

```hcl
module "consul" {
  source = "github.com/hashicorp/example"
}
```

The following example clones the `example` module from GitHub over SSH:

```hcl
module "consul" {
  source = "git@github.com:hashicorp/example.git"
}
```
#### Install modules from a Git repository

The following example clones the `example` module from a general Git repository over HTTP:

```hcl
module "vpc" {
  source = "git::https://example.com/vpc.git"
}
```

The following example clones the `example` module from a general Git repository over SSH:

```hcl
module "storage" {
  source = "git::ssh://username@example.com/storage.git"
}
```

The following example clones the `storage` module from a general Git repository over SSH using the alternate, scp-like syntax:

```hcl
module "storage" {
  source = "git::username@example.com:storage.git"
}
```

#### Install modules from a repository listed hosted on BitBucket 

The following example clones a module named `consul` from a Git repository hosted on BitBucket:

```hcl
module "consul" {
  source = "bitbucket.org/hashicorp/terraform-consul-aws"
}
```

In the following example, Terraform connects to the repository over HTTP:

```hcl
module "vpc" {
  source = "hg::http://example.com/vpc.hg"
}
```

#### Install modules from a Mercurial repository

The following clones a module from a Mercurial repository:

```hcl
module "vpc" {
  source = "hg::http://example.com/vpc.hg"
}
```

#### Query an HTTPS URL for the module source

In the following example, Terraform extracts a module source address from the `vpc-module.zip` file:

```hcl
module "vpc" {
  source = "https://example.com/vpc-module.zip"
}
```

The following example uses the `archive=zip` query parameter to extract a module source address from a URL that has an archive file extension other than the [natively-supported extension](#http-urls):

```hcl
module "vpc" {
  source = "https://example.com/vpc-module?archive=zip"
}
```

#### Install a module from an S3 bucket object

The following example installs a module from the `vpc.zip` object in an S3 bucket: 

```hcl
module "consul" {
  source = "s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/vpc.zip"
}
```

#### Install a module from a GCS bucket

The following example installs a module from the `foomodule.zip` object in a GCS bucket:
 
```hcl
module "consul" {
  source = "gcs::https://www.googleapis.com/storage/v1/modules/foomodule.zip"
}
```

### Install a specific revision

The following example instructs Terraform to clone a version of the module tagged as `v1.2.0` in a Git repository:

```hcl
module "vpc" {
  source = "git::https://example.com/vpc.git?ref=v1.2.0"
}
```

The following example instructs Terraform to clone the version of a module identified by its SHA-1 hash in a Git repository:

```hcl
module "storage" {
  source = "git::https://example.com/storage.git?ref=51d462976d84fdea54b47d80dcabbf680badcdb8"
}
```

The following example instructs Terraform to clone a version of the module tagged as `v1.2.0` in a Mercurial repository:

```hcl
module "vpc" {
  source = "hg::http://example.com/vpc.hg?ref=v1.2.0"
}

```
### Specify a module version in a registry

In the following example, Terraform installs the Consul module for AWS version `0.10.0` or newer of module:

```hcl
module "consul" {
  source  = "hashicorp/consul/aws"
  version = ">= 0.10.0"

  servers = 3
}
```

### Specify depth of clone

The following example clones a module from a Git repository using the most recent commit of `v1.2.01:

```hcl
module "vpc" {
  source = "git::https://example.com/vpc.git?depth=1&ref=v1.2.0"
}
```

### Create multiple instances of module resources

You can use either `count` or the `for_each` block to create multiple instances of module resources. The `count` argument is most suitable for creating multiple instances that are identical or nearly identical. The `for_each` argument is most suitable for creating multiple similar instances that you capture and reference from a map or set.

<Tabs>

<Tab heading="count"> 

In the following example, Terraform creates three EC2 instances, each with a unique name from the `instance_names` list:

```hcl
locals {
  instance_names = ["example-instance-1", "example-instance-2", "example-instance-3"]
}

module "ec2_instance" {
  source  = "terraform-aws-modules/ec2-instance/aws"
  version = "6.0.2"
  count   = length(local.instance_names)

  name           = local.instance_names[count.index]
  ami            = data.aws_ami.latest_amazon_linux.id
  instance_type  = "t2.micro"

  depends_on = [aws_s3_bucket.example]
}

```

</Tab>

<Tab heading="for_each">

In the following example, Terraform creates one EC2 instance for each key in `local.instance_configs`, allowing you to customize properties per instance:

```hcl
locals {
  instance_configs = {
    "example-instance-1" = { instance_type = "t2.micro" }
    "example-instance-2" = { instance_type = "t2.small" }
    "example-instance-3" = { instance_type = "t2.medium" }
  }
}

module "ec2_instance" {
  source  = "terraform-aws-modules/ec2-instance/aws"
  version = "6.0.2"
  for_each = local.instance_configs

  name           = each.key
  ami            = data.aws_ami.latest_amazon_linux.id
  instance_type  = each.value.instance_type

  depends_on = [aws_s3_bucket.example]
}

```


</Tab>

</Tabs>

### Specify dependencies

In the following example, Terraform only creates the EC2 instance module after creating the S3 bucket resource:

```hcl
resource "aws_s3_bucket" "example" {
  bucket = "my-example-bucket-12345"
}

module "ec2_instance" {
  source  = "terraform-aws-modules/ec2-instance/aws"
  version = "6.0.2"
  name    = "example-instance"
  ami           = data.aws_ami.latest_amazon_linux.id
  instance_type = "t2.micro"

  depends_on = [aws_s3_bucket.example]
}
```

### Select an alternate provider configuration

In the following example, the `google_compute_instance` resource selects the provider configuration with the `europe` alias.

```hcl
provider "google" {
  region = "us-central1"
}

provider "google" {
  alias  = "europe"
  region = "europe-west1"
}

module "project-factory" {
  source  = "terraform-google-modules/project-factory/google"
  provider = google.europe
  # ...
}
```