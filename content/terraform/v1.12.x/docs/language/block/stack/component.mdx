---
page_title: Component block reference for Terraform Stacks
description: Use the `component` block to define infrastructure modules in your Stack configuration. Each component represents a reusable piece of infrastructure that you can provision and manage.
---

# `component` block reference

Use the `component` block to define infrastructure modules in your `tfcomponent.hcl`, which is the configuration file for your Stack. Each component represents a reusable piece of infrastructure that you can provision and manage.

> **Hands-on:** Try the [Define Stack Configuration](/terraform/tutorials/stacks/define-stack-configuration) tutorial.

## Background

The `component` block defines the infrastructure to include in your Stack. Each Stack requires at least one `component` block, and you must add a `component` block to your configuration for every module you want to include in your Stack.

Components represent individual modules that make up your infrastructure stack. Each component sources a Terraform module, receives input variables, and uses providers that you declare at the Stack level. Components can reference outputs from other components, creating dependencies between different parts of your infrastructure.

You can also define the following configuration blocks in your `tfcomponent.hcl` file:
- [`required_providers` block](/terraform/language/block/stack/required_providers) to declare which providers your Stack configuration requires so that Terraform can install and use them.
-  The [`provider` block](/terraform/language/block/provider) lets you configure providers for your Stack.
- [`variable` block](/terraform/language/block/variable) to define input variables for your Stack.
- [`output` block](/terraform/language/block/output) to define outputs that you want to refer to in the HCP Terraform UI.
- The [`locals` block](/terraform/language/block/locals) to define local values that you can use within your Stack configuration.
- The [`removed` block](/terraform/language/block/stack/removed) to define resources that you want to remove from your Stack.


## Configuration model

The `component` block supports the following arguments:

- [`component "<LABEL>"`](#component) &nbsp; block
  - [`source`](#source) &nbsp; string
  - [`version`](#version) &nbsp; string
  - [`inputs`](#inputs) &nbsp; map
  - [`providers`](#providers) &nbsp; map
  - [`depends_on`](#depends_on) &nbsp; list of references
  - [`for_each`](#for_each) &nbsp; meta-argument

## Complete configuration

All available arguments are defined in the following `component` block. The `version`, `depends_on`, and `for_each` arguments are optional.

```hcl
component "<LABEL>" {
  for_each = <MAP_OR_SET>
  source   = "<MODULE_SOURCE>"
  version  = "<VERSION_CONSTRAINT>"
  inputs = {
    <INPUT_NAME> = <VALUE>
  }
  providers = {
    <PROVIDER_NAME> = provider.<PROVIDER_TYPE>.<ALIAS>
  }
  depends_on = [component.<COMPONENT_NAME>]
}
```

## Specification

A `component` block supports the following configuration.

### `component "<LABEL>"`

The label after the `component` keyword is a name for the component, which must be unique among all components in the same Stack configuration. The name of a component can be any valid [identifier](/terraform/language/syntax/configuration#identifiers).

The following arguments are supported in a `component` block:

| Argument | Description | Type | Required? |
| --- | --- | --- | --- |
| `source` | The Terraform module to source for this component. | String | Required |
| `version` | The module version to use when sourcing from the public Terraform registry. | String | Optional |
| `inputs` | A mapping of module input variable names to values. | Map | Required |
| `providers` | A mapping of provider names to providers declared in your Stack configuration. | Map | Required |
| `depends_on` | A list of other components that HCP Terraform must execute before this component. | List | Optional |
| `for_each` | Creates multiple instances of the component based on a map or set of values. | Map or Set | Optional |

### `source`

The `source` argument specifies the Terraform module to use for this component. You can reference modules from various sources, including local paths, Git repositories, and the Terraform registry.

```hcl
component "web_server" {
  source = "./modules/web-server"
}
```

The `source` argument accepts the same module sources as the [`module` block](/terraform/language/modules/sources) in traditional Terraform configurations.

#### Summary

- Data type: String
- Default: None
- Required: Yes

### `version`

Use the `version` argument to specify which version of a module to use when sourcing from the public Terraform registry. This argument only applies when the `source` references a module from the registry.

```hcl
component "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"
}
```

#### Summary

- Data type: String
- Default: None

### `inputs`

The `inputs` argument defines a mapping of module input variable names to values. The keys of this map must correspond to the variable names defined by the source module.

```hcl
component "database" {
  source = "./modules/database"
  inputs = {
    instance_class = "db.t3.micro"
    engine_version = "13.7"
    storage_size   = 20
  }
}
```

You can use three types of values in the `inputs` map:

- **Variable references**: `var.variable_name`
- **Component outputs**: `component.component_name.output_name`
- **Literal values**: Direct HCL values such as strings, numbers, or booleans

#### Summary

- Data type: Map
- Default: None
- Required: Yes

### `providers`

The `providers` argument defines a mapping of provider names to providers declared in your Stack configuration. Modules cannot configure their own providers in Stack configurations, so you must declare providers at the Stack level and pass them to each component.

```hcl
component "storage" {
  source = "./modules/s3"
  providers = {
    aws    = provider.aws.main
    random = provider.random.this
  }
}
```

The keys in the `providers` map must match the provider names that the source module expects, and the values must reference providers declared in your Stack configuration.

#### Summary

- Data type: Map
- Default: None
- Required: Yes

### `depends_on`

The `depends_on` argument specifies explicit dependencies on other components. HCP Terraform executes components in the `depends_on` list before executing the current component.

```hcl
component "app_server" {
  source = "./modules/app-server"
  depends_on = [
    component.database,
    component.networking
  ]
}
```

You do not need to include components whose outputs you reference in the `depends_on` list because Terraform automatically recognizes those dependencies.

#### Summary

- Data type: List of references
- Default: None

### `for_each`

The `for_each` argument creates multiple instances of a component based on a map or set of values. This meta-argument lets you provision the same infrastructure pattern across multiple environments, regions, or configurations.

```hcl
component "regional_storage" {
  for_each = var.regions

  source = "./modules/storage"
  inputs = {
    region = each.value
  }
  providers = {
    aws = provider.aws.configurations[each.value]
  }
}
```

When you use `for_each`, Terraform creates one component instance for each item in the collection. You can reference individual instances using `component.regional_storage[<KEY>]` syntax.

#### Summary

- Data type: Map or Set
- Default: None

## Examples

The following examples demonstrate common use cases for `component` blocks.

### Basic component

In the following example, a `component` block defines a web server module with basic configuration:

```hcl
component "web_server" {
  source = "./modules/web-server"

  inputs = {
    instance_type = "t3.micro"
    subnet_id     = "subnet-12345678"
  }

  providers = {
    aws = provider.aws.main
  }
}
```

### Component with registry module

In the following example, a component uses a module from the Terraform registry with a specific version:

```hcl
component "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  inputs = {
    name = "main-vpc"
    cidr = "10.0.0.0/16"
    azs  = ["us-west-2a", "us-west-2b"]
  }

  providers = {
    aws = provider.aws.main
  }
}
```

### Component with dependencies

In the following example, an application server component depends on database and networking components:

```hcl
component "app_server" {
  source = "./modules/app-server"

  inputs = {
    database_url = component.database.connection_string
    vpc_id       = component.networking.vpc_id
    subnet_ids   = component.networking.private_subnet_ids
  }

  providers = {
    aws = provider.aws.main
  }

  depends_on = [
    component.database,
    component.networking
  ]
}
```

### Multiple component instances

In the following example, the `for_each` meta-argument creates storage components in multiple regions:

```hcl
component "regional_storage" {
  for_each = toset(["us-east-1", "us-west-2", "eu-west-1"])

  source = "./modules/storage"

  inputs = {
    region      = each.value
    bucket_name = "app-data-${each.value}"
  }

  providers = {
    aws = provider.aws.configurations[each.value]
  }
}
```
