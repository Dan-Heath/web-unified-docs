---
page_title: Import block reference for Terraform Stacks
description: Use the `import` block to import existing resources into your Stack components, allowing Terraform to manage previously created infrastructure.
---

# `import` block reference for Stacks

Use the `import` block to import existing resources into your Stack components, allowing Terraform to manage previously created infrastructure.

## Background

The `import` block in Stack configurations allows you to bring existing infrastructure resources under Terraform management within your Stack components. This is useful when you have resources that were created outside of Terraform and you want to manage them as part of your Stack.

Import blocks in Stacks work similarly to import blocks in traditional Terraform configurations, but they operate within the context of Stack components. You can import resources into specific components, and the imported resources become part of that component's managed infrastructure.

When you use import blocks, Terraform adds the existing resources to your Stack's state without making any changes to the actual infrastructure. This allows you to start managing the resources with Terraform going forward.

## Configuration model

The `import` block supports the following arguments:

- [`import`](#import) &nbsp; block
  - [`to`](#to) &nbsp; reference
  - [`id`](#id) &nbsp; string
  - [`for_each`](#for_each) &nbsp; meta-argument

## Complete configuration

All available arguments are defined in the following `import` block:

```hcl
import {
  for_each = <MAP_OR_SET>
  
  to = <RESOURCE_ADDRESS>
  id = "<RESOURCE_ID>"
}
```

## Specification

An `import` block supports the following configuration.

### `import`

The `import` block does not take a label. Each `import` block represents one or more resources that you want to import into your Stack.

The following arguments are supported in an `import` block:

| Argument | Description | Type | Required? |
| --- | --- | --- | --- |
| `to` | The resource address where the imported resource should be managed. | Reference | Required |
| `id` | The provider-specific identifier for the existing resource. | String | Required |
| `for_each` | Creates multiple import operations based on a map or set. | Map or Set | Optional |

### `to`

The `to` argument specifies the resource address where the imported resource should be managed within your Stack components. This should reference a resource within a component's module.

```hcl
import {
  to = component.database.aws_db_instance.main
  id = "mydb-instance-12345"
}
```

The resource address follows the pattern `component.<COMPONENT_NAME>.<RESOURCE_TYPE>.<RESOURCE_NAME>` for resources managed by components.

#### Summary

- Data type: Reference
- Default: None
- Required: Yes

### `id`

The `id` argument specifies the provider-specific identifier for the existing resource that you want to import. This identifier format varies by provider and resource type.

```hcl
import {
  to = component.storage.aws_s3_bucket.main
  id = "my-existing-bucket"
}
```

Check the provider documentation for the specific resource type to determine the correct identifier format.

#### Summary

- Data type: String
- Default: None
- Required: Yes

### `for_each`

The `for_each` meta-argument allows you to import multiple resources based on a map or set of values. This is useful when importing multiple similar resources.

```hcl
import {
  for_each = var.existing_buckets
  
  to = component.regional_storage[each.key].aws_s3_bucket.main
  id = each.value
}
```

#### Summary

- Data type: Map or Set
- Default: None

## Import workflow

To import existing resources into your Stack, follow this workflow:

1. **Define the component** that will manage the imported resource
2. **Add an `import` block** specifying the resource to import
3. **Run `terraform plan`** to see the import operation
4. **Apply the configuration** to import the resource
5. **Remove the `import` block** after successful import
6. **Verify the resource** is now managed by your Stack

## Examples

The following examples demonstrate common use cases for `import` blocks in Stacks.

### Basic resource import

In the following example, an existing S3 bucket is imported into a storage component:

```hcl
# Component that will manage the imported resource
component "storage" {
  source = "./modules/s3"
  
  inputs = {
    bucket_name = "my-existing-bucket"
  }
  
  providers = {
    aws = provider.aws.main
  }
}

# Import the existing bucket
import {
  to = component.storage.aws_s3_bucket.main
  id = "my-existing-bucket"
}
```

### Importing multiple resources

In the following example, multiple existing resources are imported using `for_each`:

```hcl
variable "existing_buckets" {
  type = map(string)
  default = {
    "us-east-1" = "my-bucket-us-east-1"
    "us-west-2" = "my-bucket-us-west-2"
  }
}

component "regional_storage" {
  for_each = var.existing_buckets
  
  source = "./modules/s3"
  
  inputs = {
    bucket_name = each.value
    region      = each.key
  }
  
  providers = {
    aws = provider.aws.configurations[each.key]
  }
}

# Import all existing buckets
import {
  for_each = var.existing_buckets
  
  to = component.regional_storage[each.key].aws_s3_bucket.main
  id = each.value
}
```

### Importing database resources

In the following example, an existing RDS database instance is imported:

```hcl
component "database" {
  source = "./modules/rds"
  
  inputs = {
    identifier     = "prod-database"
    instance_class = "db.t3.medium"
    engine_version = "13.7"
  }
  
  providers = {
    aws = provider.aws.main
  }
}

# Import the existing database
import {
  to = component.database.aws_db_instance.main
  id = "prod-database"
}
```

### Importing Kubernetes resources

In the following example, existing Kubernetes resources are imported into a Stack:

```hcl
component "k8s_app" {
  source = "./modules/kubernetes-app"
  
  inputs = {
    namespace = "production"
    app_name  = "web-app"
  }
  
  providers = {
    kubernetes = provider.kubernetes.main
  }
}

# Import existing namespace
import {
  to = component.k8s_app.kubernetes_namespace.main
  id = "production"
}

# Import existing deployment
import {
  to = component.k8s_app.kubernetes_deployment.app
  id = "production/web-app"
}
```

### Importing network resources

In the following example, existing VPC and subnet resources are imported:

```hcl
component "networking" {
  source = "./modules/vpc"
  
  inputs = {
    vpc_cidr = "10.0.0.0/16"
    azs      = ["us-west-2a", "us-west-2b"]
  }
  
  providers = {
    aws = provider.aws.main
  }
}

# Import existing VPC
import {
  to = component.networking.aws_vpc.main
  id = "vpc-12345678"
}

# Import existing subnets
import {
  for_each = toset(["subnet-11111111", "subnet-22222222"])
  
  to = component.networking.aws_subnet.private[each.value]
  id = each.value
}
```

### Importing with complex resource addressing

In the following example, resources with complex addressing patterns are imported:

```hcl
component "application" {
  source = "./modules/multi-tier-app"
  
  inputs = {
    environment = "production"
    tiers       = ["web", "api", "cache"]
  }
  
  providers = {
    aws = provider.aws.main
  }
}

# Import load balancer
import {
  to = component.application.aws_lb.main
  id = "arn:aws:elasticloadbalancing:us-west-2:123456789012:loadbalancer/app/my-lb/1234567890123456"
}

# Import auto scaling group
import {
  to = component.application.aws_autoscaling_group.web
  id = "web-tier-asg"
}

# Import multiple security groups
import {
  for_each = toset(["web", "api", "cache"])
  
  to = component.application.aws_security_group.tier[each.value]
  id = "${each.value}-tier-sg"
}
```