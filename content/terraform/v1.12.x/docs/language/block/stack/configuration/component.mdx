---
page_title: component block reference for Terraform Stacks
description: Use the `component` block to define infrastructure modules in your Stack configuration. Each component represents a reusable piece of infrastructure that you can provision and manage.
---

# `component` block reference

Use the `component` block to source the individual modules that make up your Stack. You can define `component` blocks in a `<NAME>.tfcomponent.hcl` file, which is the configuration file for your Stack. Each component represents a reusable piece of infrastructure that you can provision and manage.

## Background

> **Hands-on:** Try the [Define Stack Configuration](/terraform/tutorials/stacks/define-stack-configuration) tutorial.

The `component` block defines the infrastructure to include in your Stack. Each Stack requires at least one `component` block, and you must add a `component` block to your configuration for every module you want to include in your Stack.

Each component sources a Terraform module, can receive input variables, and accepts providers that you declare at the Stack level. You can define the following configuration blocks in a `tfcomponent.hcl` file:
- Use the [`required_providers` block](/terraform/language/block/stack/required_providers) to declare which providers your Stack configuration requires so that Terraform can install and use them.
- Use the [`provider` block](/terraform/language/block/provider) to configure providers, then pass that configuration to a component.
- Use the [`variable` block](/terraform/language/block/variable) to define input variables for a Stack.
- Use the [`output` block](/terraform/language/block/output) to define outputs that you want to refer to in the HCP Terraform UI.
- Use the [`locals` block](/terraform/language/block/locals) to define local values that you can use within your Stack configuration.
- Use the [`removed` block](/terraform/language/block/stack/removed) to define the components you want to remove from your Stack.

## Configuration model

The `component` block supports the following arguments:

- [`component "<LABEL>"`](#component) &nbsp; block
  - [`source`](#source) &nbsp; string
  - [`version`](#version) &nbsp; string
  - [`inputs`](#inputs) &nbsp; map
  - [`providers`](#providers) &nbsp; map
  - [`depends_on`](#depends_on) &nbsp; list of references
  - [`for_each`](#for_each) &nbsp; meta-argument

## Complete configuration

All available arguments are defined in the following `component` block. The `source`, `inputs`, and `providers` arguments are required.

```hcl
component "<LABEL>" {
  for_each = <MAP_OR_SET>
  source   = "<MODULE_SOURCE>"
  version  = "<VERSION_CONSTRAINT>"
  inputs = {
    <INPUT_NAME> = <VALUE>
  }
  providers = {
    <PROVIDER_NAME> = provider.<PROVIDER_TYPE>.<ALIAS>
  }
  depends_on = [component.<COMPONENT_NAME>]
}
```

## Specification

A `component` block supports the following configuration.

### `component "<LABEL>"`

The label after the `component` keyword is a name for the component, which must be unique among all components in the same Stack configuration. The name of a component can be any valid [identifier](/terraform/language/syntax/configuration#identifiers).

The following arguments are supported in a `component` block:

| Argument | Description | Type | Required? |
| --- | --- | --- | --- |
| `source` | The Terraform module to source for this component. | String | Required |
| `version` | The module version to use when sourcing from the public Terraform registry. | String | Optional |
| `inputs` | A mapping of module input variable names to values. | Map | Required |
| `providers` | A mapping of provider names to providers declared in your Stack configuration. | Map | Required |
| `depends_on` | A list of other components that HCP Terraform must execute before this component. | List | Optional |
| `for_each` | Creates multiple instances of the component based on a map or set of values. | Map or Set | Optional |

### `source`

The `source` argument specifies the Terraform module to use for this component. You can reference modules from various sources, including local paths, Git repositories, the [Terraform registry](https://registry.terraform.io/), and the [HCP Terraform private registry](/terraform/cloud-docs/registry).

```hcl
component "<LABEL>" {
  source = "<NAMESPACE>/<NAME>/<PROVIDER>"
}
```

The `source` argument accepts the same module sources as the [`module` block](/terraform/language/modules/sources) in traditional Terraform configurations.

#### Summary

- Data type: String
- Default: None
- Required: Yes

### `version`

Use the `version` argument to specify which version of a module to use when sourcing from the public Terraform registry or private HCP Terraform registry.

```hcl
component "<LABEL>" {
  source  = "<NAMESPACE>/<NAME>/<PROVIDER>"
  version = "<VERSION_CONSTRAINT>"
}
```

The `version` argument accepts a [version constraint string](/terraform/language/expressions/version-constraints). Terraform uses the newest installed version of the module that meets the constraint. When an acceptable version isn't installed, Terraform downloads the newest version that meets the constraint. We recommend explicitly constraining the acceptable version numbers to avoid unexpected or unwanted changes.

<!-- TODO: Is this true? OR is there a stack command to run? -->

You must run [`terraform init`](/terraform/cli/commands/init) after modifying the `version` argument so that Terraform can update the local code.

You can only use the `version` argument when the [`source` argument](#source) points to a module listed in a registry, such as the public [Terraform Registry](https://registry.terraform.io/)
or [HCP Terraform's private module registry](/terraform/cloud-docs/registry). Modules sourced from local file paths do not support `version` because they're loaded from the same source repository and always share the same version as their caller.


#### Summary

- Data type: String
- Default: None

### `inputs`

The `inputs` argument defines a mapping of module input variable names to values. The keys of this map must correspond to the variable names defined by the source module.

```hcl
component "database" {
  source = "./modules/database"
  inputs = {
    instance_class = "db.t3.micro"
    engine_version = "13.7"
    storage_size   = 20
  }
}
```

You can use three types of values in the `inputs` map:

- **Variable references**: `var.variable_name`
- **Component outputs**: `component.component_name.output_name`
- **Literal values**: Direct HCL values such as strings, numbers, or booleans

#### Summary

- Data type: Map
- Default: None
- Required: Yes

### `providers`

The `providers` argument defines a mapping of provider names to providers declared in your Stack configuration. Modules cannot configure their own providers in Stack configurations, so you must declare providers at the Stack level and pass them to each component.

```hcl
component "storage" {
  source = "./modules/s3"
  providers = {
    aws    = provider.aws.main
    random = provider.random.this
  }
}
```

The keys in the `providers` map must match the provider names that the source module expects, and the values must reference providers declared in your Stack configuration.

#### Summary

- Data type: Map
- Default: None
- Required: Yes

### `depends_on`

The `depends_on` argument specifies explicit dependencies on other components. HCP Terraform executes components in the `depends_on` list before executing the current component.

```hcl
component "app_server" {
  source = "./modules/app-server"
  depends_on = [
    component.database,
    component.networking
  ]
}
```

You do not need to include components whose outputs you reference in the `depends_on` list because Terraform automatically recognizes those dependencies.

#### Summary

- Data type: List of references
- Default: None

### `for_each`

The `for_each` argument creates multiple instances of a component based on a map or set of values. This meta-argument lets you provision the same infrastructure pattern across multiple environments, regions, or configurations.

```hcl
component "regional_storage" {
  for_each = var.regions

  source = "./modules/storage"
  inputs = {
    region = each.value
  }
  providers = {
    aws = provider.aws.configurations[each.value]
  }
}
```

When you use `for_each`, Terraform creates one component instance for each item in the collection. You can reference individual instances using `component.regional_storage[<KEY>]` syntax.

#### Summary

- Data type: Map or Set
- Default: None

## Examples

The following examples demonstrate common use cases for `component` blocks.

### Basic component

In the following example, a `component` block defines a web server module with basic configuration:

```hcl
component "web_server" {
  source = "./modules/web-server"

  inputs = {
    instance_type = "t3.micro"
    subnet_id     = "subnet-12345678"
  }

  providers = {
    aws = provider.aws.main
  }
}
```

### Component with registry module

In the following example, a component uses a module from the Terraform registry with a specific version:

```hcl
component "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  inputs = {
    name = "main-vpc"
    cidr = "10.0.0.0/16"
    azs  = ["us-west-2a", "us-west-2b"]
  }

  providers = {
    aws = provider.aws.main
  }
}
```

### Component with dependencies

In the following example, an application server component depends on database and networking components:

```hcl
component "app_server" {
  source = "./modules/app-server"

  inputs = {
    database_url = component.database.connection_string
    vpc_id       = component.networking.vpc_id
    subnet_ids   = component.networking.private_subnet_ids
  }

  providers = {
    aws = provider.aws.main
  }

  depends_on = [
    component.database,
    component.networking
  ]
}
```

### Multiple component instances

In the following example, the `for_each` meta-argument creates storage components in multiple regions:

```hcl
component "regional_storage" {
  for_each = toset(["us-east-1", "us-west-2", "eu-west-1"])

  source = "./modules/storage"

  inputs = {
    region      = each.value
    bucket_name = "app-data-${each.value}"
  }

  providers = {
    aws = provider.aws.configurations[each.value]
  }
}
```
