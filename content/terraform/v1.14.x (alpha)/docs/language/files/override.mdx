---
page_title: Override files - Configuration Language
description: >-
  Override files merge additional settings into existing configuration objects.
  Learn how to use override files and about merging behavior.
---

# Override files

Terraform normally loads all of the `.tf` and `.tf.json` files within a directory and expects each one to define a distinct set of configuration objects. If two files attempt to define the same object, Terraform returns an error.

In some rare cases, it is convenient to be able to override specific portions of an existing configuration object in a separate file. For example, a human-edited configuration file in the Terraform language native syntax could be partially overridden using a programmatically-generated file in JSON syntax.

For these rare situations, Terraform has special handling of any configuration file whose name ends in `_override.tf` or `_override.tf.json`. This special handling also applies to a file named literally `override.tf` or `override.tf.json`.

Terraform initially skips these _override files_ when loading configuration, and then afterwards processes each one in turn (in lexicographical order). For each top-level block defined in an override file, Terraform attempts to find an already-defined object corresponding to that block and then merges the override block contents into the existing object.

Use override files only in special circumstances. Over-use of override files hurts readability, since a reader looking only at the original files cannot easily see that some portions of those files have been overridden without consulting all of the override files that are present. When using override files, use comments in the original files to warn future readers about which override files apply changes to each block.

## Example

Assume you you have a Terraform configuration `example.tf` that specifies an `aws_instance` resource with an `ami` argument of `ami-408c7f28`.

<CodeBlockConfig filename="example.tf">

```hcl
resource "aws_instance" "web" {
  instance_type = "t2.micro"
  ami           = "ami-408c7f28"
}
```

</CodeBlockConfig>

If you have `override.tf` file that specifies an `aws_instance` resource with an `ami` argument of `foo`, then Terraform will merge the latter into the former.

<CodeBlockConfig filename="override.tf">

```hcl
resource "aws_instance" "web" {
  ami = "foo"
}
```

</CodeBlockConfig>

The following is the merged configuration that Terraform will use. Terraform overrides the `ami` argument with the value from the `override.tf` file.

<CodeBlockConfig heading="Merged configuration">

```hcl
resource "aws_instance" "web" {
  instance_type = "t2.micro"
  ami           = "foo"
}
```

</CodeBlockConfig>

## Merge behavior

The merge behavior is slightly different for each block type. In addition, some constructs within certain blocks are merged in a special way.

The general rule is:

- A top-level block in an override file merges with a block in a normal configuration file that has the same block header. The block _header_ is the block type and any quoted labels that follow it.

- Within a top-level block, an attribute argument within an override block replaces any argument of the same name in the original block.

- Within a top-level block, any nested blocks within an override block replace _all_ blocks of the same type in the original block. Any block types that do not appear in the override block remain from the original block.

- The contents of nested configuration blocks are not merged.

- The resulting _merged block_ must still comply with any validation rules that apply to the given block type.

If more than one override file defines the same top-level block, the overriding effect is compounded, with later blocks taking precedence over earlier blocks. Overrides are processed in order first by filename (in lexicographical order) and then by position in each file.

The following sections describe the special merge behaviors that apply to specific arguments within certain top-level block types.

### Merge `resource` and `data` blocks

Within a `resource` block, Terraform merges the contents of any `lifecycle` nested block on an argument-by-argument basis. For example, if the original block has an `ignore_changes` argument, then it will be preserved even if the override block sets the `create_before_destroy` argument.

If an overriding `resource` block contains one or more `provisioner` blocks, then Terraform ignores any `provisioner` blocks in the original block.

If an overriding `resource` block contains a `connection` block, Terraform completely overrides any `connection` block present in the original block.

The `depends_on` meta-argument may not be used in override blocks. It will produce an error.

### Merge `variable` blocks

Terraform merges the arguments within a `variable` block in the standard way (override arguments replace original arguments). However, some special considerations apply due to the interactions between the `type` and `default` arguments.

If the original block defines a `default` value and an override block changes the variable's `type`, Terraform attempts to convert the default value to the overridden type. Terraform will produce an error if it cannot convert the default value to the overridden type.

Conversely, if the original block defines a `type` and an override block changes the `default`, the overridden default value must be compatible with the original type specification.

### Merge `output` blocks

You may not use the `depends_on` meta-argument in override blocks. It will produce an error.

### Merge `locals` blocks

Each `locals` block defines a number of named values. Terraform merges overrides on a value-by-value basis, ignoring the `locals` block they are defined in.

### Merge `terraform` blocks

Terraform considers the settings within `terraform` blocks individually when merging.

If the configuration sets the `required_providers` argument, Terraform merges its value on an element-by-element basis. This allows an override block to adjust the constraint for a single provider without affecting the constraints for other providers.

In both the `required_version` and `required_providers` settings, each override constraint entirely replaces the constraints for the same component in the original block. If both the base block and the override block both set `required_version`, then Terraform ignores the constraints in the base block.

If the override block defines a backent (either `cloud` or `backend`), Terraform completely overrides any backend block present in the original block. For example, if the original block sets a `cloud` block and the override block sets a `backend` block, then Terraform will use the `backend` block specified in the override file. Similarly, if the original block sets a `backend` block and the override block sets a `cloud` block, then Terraform will use the `cloud` block specified in the override file.