---
page_title: 'Plugin Development - Acceptance Testing: Import mode'
description: |-
  _Import_ mode is used for testing resource functionality to import existing
  infrastructure into a Terraform statefile, using real Terraform import logic.
---

# Acceptance Tests: Import mode

_Import_ is the workflow that brings existing infrastructure into Terraform,
without altering the infrastructure itself. For reference information about the
_Import_ workflow: [Terraform
CLI](https://developer.hashicorp.com/terraform/cli/import),
[Framework](https://developer.hashicorp.com/terraform/plugin/framework/resources/import),
[SDKv2](https://developer.hashicorp.com/terraform/plugin/sdkv2/resources/import).

For example: a user has an existing Amazon S3 bucket, and they would like to
manage it in Terraform. They write two configuration blocks: one to manage the
resource and one to import the resource.

```terraform
provider "aws" {
  region = "us-east-2"
}

resource "aws_s3_bucket" "uploads" {
  bucket = "uploads-4cc4274b28"
}

import {
  to = aws_s3_bucket.uploads
  id = "uploads-4cc4274b28"
}
```

```shell
$ terraform plan

aws_s3_bucket.uploads: Preparing import... [id=uploads-4cc4274b28]
aws_s3_bucket.uploads: Refreshing state... [id=uploads-4cc4274b28]

Terraform will perform the following actions:

  # aws_s3_bucket.uploads will be imported
    resource "aws_s3_bucket" "uploads" {
        acceleration_status         = null
        arn                         = "arn:aws:s3:::uploads-4cc4274b28"
        bucket                      = "uploads-4cc4274b28"
        bucket_domain_name          = "uploads-4cc4274b28.s3.amazonaws.com"
        bucket_prefix               = null
        bucket_regional_domain_name = "uploads-4cc4274b28.s3.us-east-2.amazonaws.com"
        hosted_zone_id              = "Z2O1EMRO9K5GLX"
        id                          = "uploads-4cc4274b28"
        object_lock_enabled         = false
        policy                      = null
        region                      = "us-east-2"
        request_payer               = "BucketOwner"
        tags                        = {}
        tags_all                    = {}

        grant {
            id          = "8019978e4a4e36616b36617211016ede11c65e51a05ed16768f08717a2157977"
            permissions = [
                "FULL_CONTROL",
            ]
            type        = "CanonicalUser"
            uri         = null
        }

        server_side_encryption_configuration {
            rule {
                bucket_key_enabled = true

                apply_server_side_encryption_by_default {
                    kms_master_key_id = null
                    sse_algorithm     = "AES256"
                }
            }
        }

        versioning {
            enabled    = false
            mfa_delete = false
        }
    }

Plan: 1 to import, 0 to add, 0 to change, 0 to destroy.
```

```
$ terraform apply

aws_s3_bucket.uploads: Preparing import... [id=uploads-4cc4274b28]
aws_s3_bucket.uploads: Refreshing state... [id=uploads-4cc4274b28]

Terraform will perform the following actions:

  # aws_s3_bucket.uploads will be imported
    resource "aws_s3_bucket" "uploads" {
	// omitted for brevity
    }

Plan: 1 to import, 0 to add, 0 to change, 0 to destroy.
aws_s3_bucket.uploads: Importing... [id=uploads-4cc4274b28]
aws_s3_bucket.uploads: Import complete [id=uploads-4cc4274b28]

Apply complete! Resources: 1 imported, 0 added, 0 changed, 0 destroyed.
```

After the resource is imported into Terraform state, they can manage the bucket
in Terraform and use it as a building block for new infrastructure. They can
also remove the `import` block -- it has no effect on an already-imported
resource.

```terraform
provider "aws" {
  region = "us-east-2"
}

resource "aws_s3_bucket" "uploads" {
  bucket = "uploads"

  tags = {
    Application = "the-uploader"
  }
}
```

```shell
$ terraform plan

➜  import-mode-docs TF_IN_AUTOMATION=1 terraform plan
aws_s3_bucket.uploads: Refreshing state... [id=uploads-4cc4274b28]

Terraform used the selected providers to generate the following execution plan. Resource
actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # aws_s3_bucket.uploads will be updated in-place
  ~ resource "aws_s3_bucket" "uploads" {
      + force_destroy               = false
        id                          = "uploads-4cc4274b28"
      ~ tags                        = {
          + "Application" = "the-uploader"
        }
      ~ tags_all                    = {
          + "Application" = "the-uploader"
        }
        # (11 unchanged attributes hidden)

        # (3 unchanged blocks hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.

$ terraform apply

➜  import-mode-docs terraform apply -auto-approve
aws_s3_bucket.uploads: Refreshing state... [id=uploads-4cc4274b28]

Terraform used the selected providers to generate the following execution plan. Resource
actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # aws_s3_bucket.uploads will be updated in-place
  ~ resource "aws_s3_bucket" "uploads" {
      + force_destroy               = false
        id                          = "uploads-4cc4274b28"
      ~ tags                        = {
          + "Application" = "the-uploader"
        }
      ~ tags_all                    = {
          + "Application" = "the-uploader"
        }
        # (11 unchanged attributes hidden)

        # (3 unchanged blocks hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.
aws_s3_bucket.uploads: Modifying... [id=uploads-4cc4274b28]
aws_s3_bucket.uploads: Modifications complete after 1s [id=uploads-4cc4274b28]

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.
```

In provider acceptance tests, _Import_ mode is used for testing resource
functionality to import existing infrastructure into a Terraform statefile,
using real Terraform import functionality.

At its core, _Import_ mode runs the _Import_ workflow and checks: does a
resource added by _Import_ match a resource added by _Lifecycle_ methods (i.e.
_Create_)?

In common testing terminology, _Import_ mode uses a resource added to Terraform
by _Create_ as the _expected result_.

_Import_ mode uses a resource added to Terraform by _Import_ as the _actual
result_.

_Import_ mode runs a deep comparison of the two data structures. The test step
passes :green_check_mark: only if the two data structures match.

## Reference

### Testing the `terraform import` workflow

#### _Import_ mode setup

| Field                                                    |                                                    |
|----------------------------------------------------------|----------------------------------------------------|
| `ImportState`                                            | `true`                                             |
| `ResourceName`<br/>`ImportStateId`<br/>`ImportStateFunc` |  Required. Identifies the resource to be imported. |
| `ImportStatePrefix`                                      |                                                    |


#### Configuration source

| Field             |     |
|-------------------|-----|
| `<none>`          |     |
| `Config`          |     |
| `ConfigFile`      |     |
| `ConfigDirectory` |     |

#### Tests

| Field                     |     |
|---------------------------|-----|
| `ImportStateChecks`       |     |
| `ImportStateVerify`       |     |
| `ImportStateVerifyIgnore` |     |

```go
func TestImportCommand(t *testing.T) {
	t.Parallel()

	providerFactories := map[string]func() (tfprotov6.ProviderServer, error) {
		// TODO
	}

	step1 := r.TestStep{
		// TODO: a runnable provider
		Config: `resource "examplecloud_thing" "test" {}`,
	}

	step2 := r.TestStep{
		ImportState:       true,
		ResourceName:      "examplecloud_thing.test",
		ImportStateVerify: true,
	})

	r.UnitTest(t, r.TestCase{
		ProtoV5ProviderFactories: providerFactories,
		Steps: []r.TestStep{step1, step2},
	})
}
```

```
$ go test ./[package] -run=TestImportCommand

[ output ]
```

### Testing the plannable import workflow

#### _Import_ mode setup

| Field                                                    |                                                    |
|----------------------------------------------------------|----------------------------------------------------|
| `ImportState`                                            | `true`                                             |
| `ImportStateKind`                                        | `resource.ImportBlockWithID`                       |
| `ResourceName`<br/>`ImportStateId`<br/>`ImportStateFunc` |  Required. Identifies the resource to be imported. |
| `ImportStatePrefix`                                      |                                                    |


#### Configuration source

| Field             |     |
|-------------------|-----|
| `<none>`          |     |
| `Config`          |     |
| `ConfigFile`      |     |
| `ConfigDirectory` |     |

#### Tests

| Field              |     |
|--------------------|-----|
| `ImportPlanChecks` |     |

```go
func TestImportBlockWithID(t *testing.T) {
	t.Parallel()

	providerFactories := map[string]func() (tfprotov6.ProviderServer, error) {
		// TODO
	}

	step1 := r.TestStep{
		Config: `resource "examplecloud_thing" "test" {}`,
	}

	step2 := r.TestStep{
		ImportState:       true,
		ImportStateKind:   resource.ImportBlockWithID,
		ResourceName:      "examplecloud_thing.test",
	})

	r.UnitTest(t, r.TestCase{
		ProtoV5ProviderFactories: providerFactories,
		Steps: []r.TestStep{step1, step2},
	})
}

```
$ go test ./[package] -run=TestImportBlockWithID

[ output ]
```

#### Testing the plannable import workflow using a managed resource identity

#### _Import_ mode setup

| Field                                                    |                                                    |
|----------------------------------------------------------|----------------------------------------------------|
| `ImportState`                                            | `true`                                             |
| `ImportStateKind`                                        | `resource.ImportBlockWithResourceIdentity`         |
| `ResourceName`<br/>`ImportStateId`<br/>`ImportStateFunc` |  Required. Identifies the resource to be imported. |
| `ImportStatePrefix`                                      |                                                    |


#### Configuration source

| Field             |     |
|-------------------|-----|
| `<none>`          |     |
| `Config`          |     |
| `ConfigFile`      |     |
| `ConfigDirectory` |     |

#### Tests

| Field              |     |
|--------------------|-----|
| `ImportPlanChecks` |     |

```go
func TestImportBlockWithResourceIdentity(t *testing.T) {
	t.Parallel()

	providerFactories := map[string]func() (tfprotov6.ProviderServer, error) {
		// TODO
	}

	step1 := r.TestStep{
		Config: `resource "examplecloud_thing" "test" {}`,
	}

	step2 := r.TestStep{
		ImportState:       true,
		ImportStateKind:   resource.ImportBlockWithResourceIdentity,
		ResourceName:      "examplecloud_thing.test",
	})

	r.UnitTest(t, r.TestCase{
		ProtoV5ProviderFactories: providerFactories,
		Steps: []r.TestStep{step1, step2},
	})
}

```
$ go test ./[package] -run=TestImportBlockWithResourceIdentity

[ output ]
```
