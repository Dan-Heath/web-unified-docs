---
page_title: Identity
description: >-
Learn how to implement resource identity in the Terraform plugin framework.
---

# Resource identity

A resource identity is a data object, determined by the provider, that is stored alongside the resource state to uniquely identify a remote object. A resource identity should have the following properties:
- The resource identity must correspond to at most one remote object per provider, across all instances of that provider.
- Given a resource identity (during `import`), the provider must be able to determine whether the corresponding remote object exists, and if so, return the resource state.
- Unless the resource identity schema is being upgraded, the identity data must not change during the lifecycle of the remote object.
- That is, from the creation of the remote object in the remote system until its destruction.

## Resource Identity Schema

To define the identity object for a managed resource, a resource identity [schema](/terraform/plugin/framework/handling-data/schemas) is provided that consists of a map of attribute names and associated behaviors. This is similar to the existing resource state schema, with a few key differences:

1. The identity schema only supports primitive types and list types such as:
    - `BoolAttribute`
    - `Float32Attribute`
    - `Float64Attribute`
    - `Int32Attribute`
    - `Int64Attribute`
    - `NumberAttribute`
    - `StringAttribute`
    - `ListAttribute`
        - `ElementType: types.BoolType`
        - `ElementType: types.Float32Type`
        - `ElementType: types.Float64Type`
        - `ElementType: types.Int32Type`
        - `ElementType: types.Int64Type`
        - `ElementType: types.NumberType`
        - `ElementType: types.StringType`

<Note>

    The ordering in lists is expected to be stable and semantically relevant.

</Note>

2. Unlike the resource state schema, the resource identity schema will not support behaviors such as Required and Computed. Two behaviors will be allowed for each attribute: `RequiredForImport` and `OptionalForImport`, which, as named, only affect behavior when importing a resource by identity.
 - `RequiredForImport` is set to true if an import block would need this information from the practitioner to import the resource.

  - `OptionalForImport` is set to true if an import block does not require this information from the practitioner to import the resource. This can be data that would normally be defaulted from the configured provider running the import.

It is expected that exactly one of `RequiredForImport` or `OptionalForImport` is set to true. Regardless of which option is used, the provider can decide exactly what data is stored in the identity during import, similar to `Computed` attributes in resource state.

3. Identity attributes are expected to be unique, immutable and fully known.

Example of an identity schema for an aws_s3_bucket:
```go
var _ resource.ResourceWithIdentity = &S3BucketResource{} // new interface

func (r *S3BucketResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "aws_s3_bucket"
}

func (r *S3BucketResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// .. existing resource schema for aws_s3_bucket
	}
}

func (r *S3BucketResource) IdentitySchema(_ context.Context, _ resource.IdentitySchemaRequest, resp *resource.IdentitySchemaResponse) {
	resp.IdentitySchema = identityschema.Schema{
		Attributes: map[string]identityschema.Attribute{
			"bucket": identityschema.StringAttribute{
				RequiredForImport: true,
			},
			"account_id": identityschema.StringAttribute{
				OptionalForImport: true,
			},
			"partition": identityschema.StringAttribute{
				OptionalForImport: true,
			},
			"region": identityschema.StringAttribute{
				OptionalForImport: true,

			},
		},
	}
}
```

## Identity Schema Usage

### Setting an Identity Schema

The provider schema type has a section for identity schemas.

```go
type ProviderSchema struct {
	// ...

	// The schemas for any identities in this provider.
	IdentitySchemas map[string]*IdentitySchema `json:"identity_schemas,omitempty"`
}
```

### Identity Schema Retrieval

The existing `terraform providers schema --json` command now includes all identity schemas in a provider.

```go
type Provider struct {
    // ... other schemas
    ResourceIdentitySchemas  map[string]*IdentitySchema                 `json:"resource_identity_schemas,omitempty"`
}

type IdentitySchema struct {
    Version    uint64                        `json:"version"`
    Attributes map[string]*IdentityAttribute `json:"attributes,omitempty"`
}

type IdentityAttribute struct {
    IdentityType      json.RawMessage `json:"type,omitempty"`
    Description       string          `json:"description,omitempty"`
    RequiredForImport bool            `json:"required_for_import,omitempty"`
    OptionalForImport bool            `json:"optional_for_import,omitempty"`
}
```

### Versioning
Each identity schema will have a version stored alongside the identity data in the state, similar to resource schemas. We don't expect the identity schema for a resource to change very often, although it could happen. In that case, we will need an upgrade method for identities, similar to resource state.

##### Example
Using an example identity schema for an AWS S3 bucket the identity schema version 0 could look like the following:
```go
{
    "account_id": {string, required_for_import:false, optional_for_import:true},
    "partition": {string, required_for_import:false, optional_for_import:true},
    "service": {string, required_for_import:false, optional_for_import:true},
    "region": {string, required_for_import:false, optional_for_import:true},
    "bucket": {string, required_for_import:true, optional_for_import:false},
}
```

Each resource instance will have a populated identity in the Terraform state that follows this schema:
```go
{
  // ...
  "resources": [
    {
      "type": "aws_s3_bucket",
      // ...
      "instances": [
        {
          // ...
          "schema_version": 0,
          "attributes": {
            // ...
          },
          "identity_schema_version": 0,
          "identity": {
            "account_id": "123456789012",
            "partition": "aws",
            "service": "s3",
            "region": "us-east-1",
            "bucket": "bucket-name"
          }
        }
      ]
    }
  ]
}
```
If at any point the S3 team decides that a different attribute is required to uniquely identify buckets, the identity schema must be updated accordingly and its version increased to 1:

```go
{
    "account_id": {string, required_for_import:false, optional_for_import:true},
    "partition": {string, required_for_import:false, optional_for_import:true},
    "service": {string, required_for_import:false, optional_for_import:true},
    "region": {string, required_for_import:false, optional_for_import:true},
    "bucket": {string, required_for_import:true, optional_for_import:false},
    "planet": {string, required_for_import:true, optional_for_import:false},
}
```

The next time Terraform interacts with this resource, it will update the identity data using a new RPC call to the provider. The updated identity data is persisted in the state along with the incremented version number:
```go
// ...
"identity_schema_version": 1,
"identity": {
  "account_id": "123456789012",
  "partition": "aws",
  "service": "s3",
  "region": "us-east-1",
  "bucket": "bucket-name",
  "planet": "earth"
}
// ...
```
Before comparing identity data from the state, it should be ensured that it always follows the latest schema version.

